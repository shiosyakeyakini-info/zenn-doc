---
title: "第１章　関数型・宣言型パラダイムの基礎"
free: true
---

## 関数型プログラミングの基礎


ReactやJetpack Composeではよく関数型プログラミングという言葉がよく用いられます。
表面的には、これらは直接的に関数を用いてUIを構築するからという側面がありますが、より根本的には**宣言型UIにおいてより普遍的**な観念を示します。

これまでの手続的・命令的プログラミングでは、フローチャートを書き、その手続きの順序の仔細が重要視されてきました。
しかしながら、この関数型プログラミングでは、手続の詳細よりも式が重要視されます。

この観念は古くはLisp, Haskellなどに見られたものですが、UI構築にも親和性が高いという観念がここ十年程度で普及してきました。
その最たる転機がReactであり、その後に登場したどの宣言的UIを採用するフレームワークも…いや、そもそも宣言的UIというもの自体が、関数型プログラミングを用いた手法だといえます。

ここでは、関数型プログラミングにおいて重要な観念を示します。
この観念は非常に抽象的なものが多いですが、UIとはどうあるべきかという指針を示します。


## 冪等性

冪等性とは、ある入力に対して、同じ操作を何度行っても結果が変わらないことを指します。
この何度というのは、数学的には同型写像で、$f(f(x)) = f(x)$であることを示します。

プログラミングにおいては、このような例が考えられます。

```dart
final trump = "MAKE AMERICA GREAT AGAIN"
    .toLowerCase()
    .toLowerCase()
    .toLowerCase();
```

この式において、`toLowerCase()`は単一の入力に対して、何度適用しても純粋に同一の結果しか返しません。
なので、数理的にもこの`toLowerCase()`という操作は、冪等性があります。

このような例をいくつか挙げてみましょう。

| 型 | 操作例（冪等なメソッド） |
| --- | --- |
| 文字列 | `toLowerCase()`, `toUpperCase()`, `trim()` |
| 数値 | `abs()`, `round()`, `floor()`, `ceil()`, `max()`, `min()` |
| 配列（List） | `sorted`, `reversed`, `where()`, `map()`（副作用がない場合） |

ここで、純粋な数学的な冪等性の説明はここで終わりますが、プログラミングにおいての冪等性は必ずしも要求しないものがあります。

それは後で説明する、「関数の合成性」です。これは一旦読み飛ばして関数の合成性を理解してから戻ってきてもらっても構いません。

関数の合成性とは、ある関数が自身と同じ型を返す必要があります。
例えば文字列に対して操作をした結果文字列を返せば、冪等性を確保できます。

しかしながら、`String.toInt()`のようなメソッドは異なる型を返してしまうため、何回呼ぶということそのものが意味不明となります。数学的な$f(x)=f(f(x))$の形を取りえません。

そこで、この関数の合成性は一旦頭から外して、同じ操作を何度繰り返しても、同一の出力が得られるなら、これは冪等とします。

その最たる例はGETリクエストのHTTP通信で、サーバーから要求を何度繰り返しても、その間に状態が変わっていなければ必ず同一のレスポンスが返ってくるはずですし、
REST APIにおいてはそのように設計されていなければなりません。

サーバーのGETリクエストはAPI仕様上何回実行しても結果が変わらないはずですから、これは成立するはずです。

```dart
final response1 = await http.get('http://example.com/')
final response2 = await http.get('http://example.com/')
final response3 = await http.get('http://example.com/')

 //理論上は冪等であるはず
// 実際にはヘッダーなどの情報は動的に毎回変更されたり、
// リクエスト時刻等の非冪等な要素が含まれる
expect(response1.data, response2.data);
expect(response2.data, response3.data);
```


## 外部状態・副作用

副作用とは、関数の外部に影響を与えることを指します。
例えば、関数がグローバル変数を直接参照したり、ファイルの書き込みや通信を行うことが副作用にあたります。

たとえば、
```dart
int calc(int a) => a + 1;
```
これは外部に何の影響も与えないため、副作用はありません。

```dart
Future<void> writeFile(String text) {
    await File('C:/Users/Alice/Desktop/sample.txt')
        .writeFile(text);
}
```

この関数は、直接的にファイルシステムという外部の状態に依存します。この処理は「アクセス権がない」「上位のディレクトリがない」「容量不足」などといった非決定論的な要因によって、操作が失敗したり成功したりします。

```dart
var counter = 0;
int calc(int a) {
    counter++;
    return a;
}

print('$counter');
calc(1);
print('$counter');
```

これはグローバル変数という外部の状態に直接操作しているため、副作用を持っています。

あるいは、この例ではどうでしょうか。

```dart
@riverpod
class CounterNotifier extends _$CounterNotifier {
    @override
    int build() => 0;

    void increment() => state++;
}
```

これは操作によって`CounterNotifier`の状態が変化するため、それがUIなり、テストなりによって呼び出しに基づいて観測されるため、**副作用が発生している**といえます。必ずしも外部の状態が副作用というわけでもなく、状態の変化を伴えばそれも副作用たり得ます。

Dartから離れて、他の言語の話もしましょう。C#の`ref`やPHPの`&`（参照渡し）は、副作用を引き起こす代表的な「言語的」機能です。これらは関数に引数として渡した変数自体の値を関数内で直接変更できるため、呼び出し元の状態が関数の実行によって変化します。これは、入力値が同じでも出力や外部状態が変わる可能性があるため、副作用とみなされます。

例えばC#では以下のようになります。

```csharp
void Increment(ref int x) {
    x++;
}

int a = 1;
Increment(ref a); // aは2になる
```

PHPでも同じように、外部の状態を直接書き換えることができます。

```php
function increment(&$x) {
    $x++;
}

$a = 1;
increment($a); // $aは2になる
```

このように、参照渡しは関数外部の変数の状態を直接変更するため、副作用が発生します。

この副作用をどのように管理するかは、フレームワークによっていくつかの思想があります。たとえばReactでは`useEffect`にて管理されるべきとありましたが、様々な文献や記事が示す通り、「**副作用**」があまりに広義過ぎて、しかもそれがコンポーネント内で解決する責務を追ってしまうがあまり、`useEffect`を使うなという風潮すら生まれてしまいました。あるいはVue.jsでは、`composable`にて副作用を閉じ込めるのがセオリーです。

一方でFlutter&Riverpodではどのように解釈されるのでしょうか。それは次の章で詳しく解説します。

## 純粋関数・参照透過性

参照透過性とは、「同じ式が常に同じ結果を返し、その式を同じ値で置き換えてもプログラムの意味が変わらない」ことを指します。

たとえば `3 + 4` という式は常に `7` なので、プログラム中のすべての `3 + 4` を `7` に置き換えても同じ結果が得られます。これは参照透過です。

一方、`DateTime.now()` や `Random().nextInt()` は、同じ式であっても毎回異なる結果を返します。これは外部に対して何かしら操作をするような副作用を持たなくとも、参照透過ではありません。外部に対して**操作はしていません（副作用自体はない）**が、**直接的に依存はしている**状態です。

もちろん、必ず同じ値を返しても、外部に影響を与える（副作用を持つ）ものは、それも参照透過ではありません。

つまり、参照透過性とは、単に同じ出力であることを要求するだけでなく、外部への影響を受けることも、及ぼすこともなく、単純に入力と出力だけで結果が決定できることを示します。

そして、このような参照透過性を持つ関数のことを、**純粋関数**と呼びます。関数型プログラミングのうち、すべての関数に対して純粋関数性を要求するものを特に純粋関数型プログラミングと呼びます。特にHaskellなどが該当します。

```dart
// 冪等だが副作用がある関数（参照透過ではない）
// 出力自体は毎回同じであるが、外部のグローバル変数を直接書き換えている
int calcCount = 0;
int calc(int a) {
    callCount++;
    return a * 2;
}

// 冪等で、副作用もないが、外部状態に依存するため参照透過でない関数
// グローバル変数が外部から書き換われば、同じ入力に対して同じ出力を得られない。
// 時間的経過（による操作）で冪等性が失われてしまう、ともいえる。
int callFactor = 2;
int calc(int a) {
    return a * callFactor;
}

// 冪等で、外部依存もなく、副作用もない、参照透過性のある関数
int calc(int a) {
    return a * 2;
}
```

例をいくつか挙げてみましょう。

| 関数の例 | 副作用あり　| 外部依存あり | 冪等性 | 参照透過　|
| --- | --- | --- | --- | --- |
| print("Hello") | ☑ | - | ☑<br>※関数の出力自体は | - |
| DateTime.now() | - | ☑ | - | - |
| 3 + 4 | - | - | ☑　| ☑　|
| Random().nextInt() | - | ☑ | - | - |
| readFile('x.txt') | ☑<br>※IOを操作する一般的な例では | ☑　| - | - |
| toLowerCase() | - | - | ☑　| ☑　|

内部で標準出力を操作してしまう関数は、結果自体は冪等にみえても、副作用があるため参照透過性がありません。

直接外部の状態に依存する関数は、多くの場合そもそも冪等でもないので、やはり参照透過性がありません。というのも、外部状態が変わってしまえばそもそも出力が変わってしまうので、「同じ外部状態であれば冪等」という条件付き冪等のような形を取るからです。


### モナド化

ここで特にHaskellにおけるモナド化、特にIOモナドについても触れます。Haskellは純粋関数型プログラミングを指向していますが、すべて純粋関数であればどうやって標準入力に値を表示させるのでしょうか？Haskellでは関数の出力を返すという形でしか値を表示できないのでしょうか？

そんなことはなく、HaskellはIOモナドという形でこれを解決しています。Haskellにおける標準入力の、いわゆる`console.log`とか`print`に相当するものがあります。`putStrLn`です。

`putStrLn`は、Haskellにおいて`String -> IO ()`という型を返します。このIOというのは不思議な型で、その時点ではIOという謎の型を返す関数ということになります。このIOはHaskellの純粋関数しかない世界で何等か評価できるものでしょうか？副作用があるのに？そんなことはできなくないですか？

実際には、副作用を予定したようなことを示す型です。予定しているだけで、直接副作用を実行しているわけではありません。屁理屈みたいに聞こえるかもしれませんが、そういうものです。抽象インターフェイスのようなものです。

というわけで、実は、そもそもHaskellでは`main`関数自体も`main :: IO ()`という型を返します。main自体もIOに対する副作用の予定を列挙したものを返しているに過ぎず、さらにその先へと副作用の実際の動作を先送りにしています。このことで、副作用の操作の仔細をHaskellの外に逃がしているような構図になります。

いきなりHaskellの話が出てきて困惑したかもしれませんが、ここで重要なのは、副作用の操作を誰が行うかという話です。これを極端な形、言語の中では一切の副作用を抽象化して外に逃がすというアプローチをしたのがHaskellであり、あるいはReactないしflutter_hooksでいうモナド化が、副作用のコンテナたる`useEffect`に当てはまるとか、変更可能な値をVue.jsで`ref`に集約するとか、そういう点で見れば理解しやすいかもしれません。

またあるいは、DI(依存性の注入)も、一連の操作の中では直接副作用に行わず、その副作用を先送りにするIOモナドの思想をオブジェクト指向に適用したものとみなすことができます。インターフェイスとDI機構を用いて操作の抽象化を行う機構と、純粋関数における副作用の隔離、全く異なるアプローチから発生した観念であるはずにもかかわらず、同じような機構となっています。

## ミュータブル・イミュータブル

概ね、ミュータブルとは値が自由に書き換えられる変数で、イミュータブルは一度評価されたあとはそれ以降書き換えられることがない変数を指します。

さらに、「浅い」イミュータブルと「深い」イミュータブルという概念があります。たとえば、インスタンスに対するメンバ変数の奥深くまでイミュータブルである変数は、深いイミュータブルであり、表面的にインスタンスが直接変更できないイミュータブルで、その中まで変更できないイミュータブルは、「浅い」イミュータブルと見做されます。

Dartの場合では浅いイミュータブルはイミュータブルと見做さないことが多いです。

```dart
const a = 1; // これはビルド時に決定されるイミュータブルな変数
final b = 1; // これは実行時に評価されるイミュータブルな変数

var c = 1; // これはあとから変更される可能性があるミュータブルな変数

// これはリストのインスタンス自体は変更できないが、リストを操作できてしまう。
// 言語によってこれは浅いイミュータブルとして扱われることもあるが、
// Dartの文脈ではミュータブルとされる。
final list1 = [0, 1, 2]; 

// これはリストの操作ができないので、名実ともにイミュータブル
final list2 = List.unmodifiable([0, 1, 2]);
```

値がイミュータブルであるかどうかも、純粋関数プログラミングでは重要な概念です。

イミュータブルにするとどのようなメリットが生まれるでしょうか。まず、先ほど例に挙げたC#やPHPの参照渡しのような副作用を、値自身が受け付けないということです。これを許してしまえば、入力した値が知らない間に書き換わったりしてしまう可能性があり、破綻してしまいます。そうすれば出力を保証しえなく、入力が純粋関数であることを破壊してしまいます。

このほか、スレッドセーフであることも理由のひとつです。これは非同期処理と深く関係していて、ここで述べるとかなり話が飛んでしまうので、あとの章に譲ります。

さらに、値に対して再現性を求めることができます。純粋関数プログラミングにおいて、同じ入力が同じ出力を返すことを証明するには、そもそもの入力の型が構造的に同一である必要があります。渡す入力全てがイミュータブルであることは、同じように定義された値は必ずいつも一緒であることの保証となります。

また、値が等価であることを、`Object.hash([ ... ])`のような形でハッシュベースで示せるため、例えば文字列をすべて一致するか確認するよりも、高速に評価することができます。

### イミュータブルの構造的保証

さて、一見`final`あるいは言語によって`final var`や`const`で定義されたクラスや配列であっても、全体がイミュータブルでなければ、多くの言語はこれらのクラスや配列を参照渡しとして引数に渡されるので、誰がどこで副作用を発生させるかわからなくなる可能性があります。


このため、値が不変であることは、単に`final`や`const`で定義されるかどうかによらず、構造的な保証が必要です。

Dartではこれを保証するライブラリとして広く使われているのがFreezedです。

```dart
@freezed
abstract class Account with _$Account {
    const factory Account({
        required String name,
        required String id,
        required DateTime createdAt,
        requierd List<Role> roles,
    }) = _Account;
}

@freezed
abstract class Role with _$Role {
    const factory Role({
        required String name,
        required String id,
    }) = _Role;
}
```

といったクラスを作成すれば、自動生成コードでイミュータブルなコードを生成します。これによって作成されたクラスは、あとから変更することができません。これはFreezedで生成されたコードに深く伝播します。Roleもfreezedで生成されたクラスであるからして、Accountに対するRoleもイミュータブルを保証できます。

さらに、`copyWith`というメソッドを自動生成します。これはたとえばKotlinの`data class`では言語仕様として組み込まれているものです。

この`copyWith`メソッドは、単に現在の値から一部分を変えたオブジェクトを返すだけでなく、何を変えてそのインスタンスを生成したかを追跡しやすくするメリットがあります。

ところで、言語によって何がイミュータブルであり、何がミュータブルかは異なります。例えば先にあった`DateTime`あるいは`Date`型は言語によってミュータブルだったりイミュータブルだったりします。

| 言語　| イミュータブル性　| 備考　|
| --- | --- | --- |
| Dart(DateTime) | イミュータブル　| `add`や`substract`というメソッドは新しいインスタンスを返却する |
| Java(java.util.Date) | ミュータブル　| いわゆる「昔からある方」 |
| Java(java.time.LocalDateTime) | イミュータブル　| いわゆる「最近推奨される方」 |
| JavaScript(Date) | ミュータブル　| `setFullYear`など直接的に設定する方法がある |
| C#(DateTime) | イミュータブル　| `AddDays`などは新しいインスタンスを返却する |
| Ruby(Time) | ミュータブル　| `.gmtime`などは自身の状態を変化させる |

関数型プログラミング的発想においては、真にすべてのオブジェクトが構造的にイミュータブルでないと、理論的保証ができませんが、実際のところ言語によってどれがイミュータブルでどれがミュータブルであるかは異なるので、意識して操作する必要があります。

## 関数合成

関数の合成とは、冪等性のときに少し出てきましたが、ある関数の出力を、別の関数の入力として使用することを指します。

これはDOMツリーやウィジェットツリーといった、ネストする階層構造を表現するのに適しているほか、文字列や配列、あるいはオブジェクトに対して抽象的かつ段階的に処理を記述することにも適しています。

```dart
final sample = "  MAKE GREAT AMERICA AGAIN "
    .toLowerCase()
    .trim();
```

このようなメソッドチェーンも高階関数といえますし、あるいはKotlin DSL、わかりやすい例でいえば、ビルド時に設定するbuild.gradleは関数の合成によって成り立っています。

```kotlin

tasks {
    withType<Test> {
        useJUnitPlatform()
        testLogging {
            events("passed", "skipped", "failed")
        }
    }
}
```

Flutterのウィジェットは表面的にはウィジェットというクラスのネストとして表現されますが、この関数の合成という概念が根底にあります。

このことは、後に登場する「宣言的」な記述をするために重要な役割を果たします。



## 高階関数

高階関数とは、他の関数を引数に取ったり、関数自体を返す関数のことです。多くのプログラミング言語では、これを簡潔に表現する手段として、ラムダ式という記法が取られます。

たとえば、`onPressed`に引数を渡すのは、高階関数の典型的な構文です。あるいは、

```dart
final list = [0, 1, 2]
    .map((e) => e * e);
```

ここでmapに渡す関数は、これも高階関数です。多くの言語では関数が第一級オブジェクトとして存在するため、このような具体的な処理を呼び出し側の操作に委ね、抽象的な操作のみを提供することが可能となります。

### 高階関数を簡潔に記述するのは比較的最近の観念

Javaには長らく高階関数という概念が無く、2014年にラムダ式が導入されるまで、先に挙げた

```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        count[0]++;
        label.setText("カウント: " + count[0]);
    }
});
```

単一のメソッドを持つインターフェイスの匿名実装という形態を取らざるを得ませんでした。これは高階関数という概念がある現代からみれば非常に冗長な設計です。

また、関数が第一級オブジェクトであったPHPやJavaScriptでも、つい最近まで(PHP 7.4<2019>, ES5<2015>)ラムダ式という記法を文法がサポートせず、

```php
$list = [1, 2, 3];
$squared = array_map(function($x) {
    return $x * $x;
}, $list);
```
や
```javascript
const list = [1, 2, 3].map(function (x) {
  return x * x;
});
```

という、ラムダ式が導入された今では冗長にしかみえない書き方をしなければなりませんでした。

この高階関数を簡潔に記述する手法は、最終的に宣言型パラダイムにおいて重要な役割を果たします。



## 宣言型パラダイム

これまで、関数型プログラミングについて述べてきましたが、最後に宣言型パラダイムとはなにかについて述べていきます。

これまでの手続き型プログラミングとは、上から下へ手続的に操作の手順を記述するものでした。すなわち**How**（どうやって）という点です。一方で、宣言型のプログラミングとは、私は何をしたいかを述べるだけという**What**（何を）に焦点を当てます。このとき、それを用いるものは、それがどうやって動作するかの仔細を知る必要がありません。

宣言型と呼べるものにはいくつか例があります。

- 正規表現
  - 正規表現は、このようにマッチするという「何に」について記述する言語であり、それが実際にどのようなプロセスで文字列探索が行われるかは、正規表現のエンジンに委ねられます。
- SQL, LINQ(C#)、コレクション操作
  - SQLもLINQも、あるいはKotlinのコレクション関数、Laravelのコレクションといったものは、あるデータセットや配列に対して、何をしたいかを記述していきます。いずれにしても、何をしたいかを述べるだけであり、具体的に表領域をどうやってキャッシュしろとか、それは遅延評価しろとか、どこかで一次変数を使うといった具体的手続に関与する必要がありません。
- 生成AIへのプロンプト、ソースコード出力
  - 広義にはこれも宣言的だと呼ぶことができます。プロンプトはしたいことを述べているだけに過ぎず、出力されたソースコードはRDBSの内部エンジンの処理の仔細のように捉えれば、同じ構図とみなせるからです。

このような宣言的操作には保守性・開発効率という点で多数のメリットがある一方で、実装の詳細のブラックボックス化は毒にもなりえます。

- ReDoS
  - ReDoSは正規表現のパターン評価に時間を要する文字列を入力することで、サービス負荷を意図的に上げる攻撃です。正規表現は宣言的にしたいことを述べるだけに過ぎず、その動作の具体的方法は実装者の責務ではありませんが、ブラックボックスだから全く知らないというわけにもいきません。ReDoSを起こさないような正規表現を組み立てるのは、正規表現を利用する側の責任にあります。
- スロークエリ
  - SQL自体はしたいことを述べる手段に過ぎませんが、適切に設計しないと極端に時間のかかるクエリが発生しえます。
- 競技プログラミング
  - 本質はスロークエリと同一ですが、より高度な最適化が求められる場面では、配列操作を宣言的に記述せず、「意図的に」手続的に記述してパフォーマンスの向上を行う場面が多々あります。
- 生成AIが出力したコードの責任を負うのは誰か
  - 当たり前ですが、生成AIが自動生成したソースコードに対しての責任を持つのは、プロンプトを投げて生成した人にあって、生成AIにはありません。これは上記の「ブラックボックスだから」と同じ理屈になります。

さて、これまで関数型プログラミングについて解説してきましたが、なぜ宣言型操作と関数型プログラミングには親和性が高いのでしょうか。

  **純粋関数**
  
したいことを述べて結果を得るためには、そのしたいこと（入力）以外の外部状態に依存することが望ましくありません。例えば、外部状態に依存する正規表現エンジンやRDBSなどというものがあれば、その入出力が不安定になってしまうかもしれません。

例えば、特定のクエリが特定の設定条件下では利用できないということがあれば、そのクエリには入出力の参照透過性に疑義が生じてしまいます。実際そういう例はしばしばあります（より具体的にはMySQL 5.7以降、`GROUP BY`で使っているカラム以外をSELECTするとエラーになるが、`GLOBAL.sql_mode`の設定内容に依存するとかそういうのです。これだとグローバル変数にSQL構文が依存しているような構図になり、外部状態に依存することになりますね。）


**高階関数**

高階関数はこれまでにも何度か登場していますが、単純にこれが発生したらこれを起こす、というイベントハンドリングや、それぞれに対して何をする、という点において、実装の具体を実装者に委ねることができます。

たとえば、`map`は配列のそれぞれに対してなにかの動作をするという抽象操作を提供しますが、具体的に何をするかというのを、ラムダ関数を用いて記述すれば、より「何をしたいか」に集中することができます。

**関数の合成性**

処理の手順ではなく処理の**構造**を重視する宣言的パラダイムにおいては、関数の合成性は重要な役割を果たします。

関数の合成ができると、全体として複雑な構造を、小さな関数に分割して、それらを連鎖的に接続することで全体を構成できるようになります。このとき、どの関数を組み合わせれば望む形になるかという点に集中できるため、「したいことを連鎖的に並べる」ための基盤といえます。

FlutterやReact、Vue.jsのコンポーネントはもちろん、メソッドチェーンやbuild.gradle(.kts)のDSL構文にいたるまで、何をしたいかという本質に集中させるための根本には、この関数の合成性というものがあります。


## まとめ

ここまでの用語を整理すると概ね下記のとおりです。

| 用語                     | 説明                                                                 | 例・備考                                      |
|--------------------------|----------------------------------------------------------------------|-----------------------------------------------|
| 冪等性                   | 同じ入力に対して何度実行しても結果が変わらない性質                  | `toLowerCase()`, HTTP GETリクエスト           |
| 外部状態・副作用         | 関数外部の状態を変更・参照すること                                   | ファイル書き込み、グローバル変数の変更、通信など         |
| 純粋関数・参照透過性     | 入力が同じなら常に同じ出力を返し、外部状態に依存・影響しない関数      | `int add(int a, int b) => a + b;`             |
| イミュータブル           | 値が変更不可であること                                              | `final`/`const`変数、Freezedクラス            |
| 関数の合成性             | 関数の出力を別の関数の入力にできる性質                              | メソッドチェーン、`map().where()`             |
| 高階関数                 | 関数を引数や戻り値に取る関数                                        | `map`, `onPressed: () => ...`                 |
| 宣言型パラダイム         | 「何をしたいか」を記述し、手続きの詳細を隠蔽するプログラミング手法    | SQL, 正規表現, FlutterのWidgetツリー          |

本章では、宣言型UIが宣言型UIたりえるための、理論的な内容について解説してきました。次の章では、これを実際にUIに応用していきます。



---
title: "第５章　Flutter&Riverpodにおけるアンチパターン"
---

## 命令形指向を捨てよ、状態本位であれ

根本的に宣言型UIとは、これまでの思考とはコペルニクス的転回が必要です。実際には`showDialog`や`TextEditingController`や`AnimationController`などの、命令的インターフェイスがFlutterには残されていますが、これは性能や宣言的に記述するとより不便が生じるからという話でした。つまり、原理原則は宣言的であるということです。

そして、UIを直接操作する手段は存在しないことも説明してきました。全ては状態に対する写像なのです。状態こそが本質であり、その状態を映し出す表現手段や、副作用を発生させる契機は、いまはUIかもしれませんが、それはMCPサーバーかもしれませんし、全く異なる操作体系かもしれません。状態に対する写像は必ずしもUIである必要がありません。これはクリーンアーキテクチャの非依存性に通じます。なんなら、Flutterがウィジェットという形を必ずしも画面に投影しません（ウィジェットテストでは）。つまりFlutterはFlutterのフレームワーク上に乗っている限り、根本的にUI非依存です。

アプリケーションの機能にとってUIが本質的でないは言い過ぎかもしれませんが、「状態」というもの本位で構築されるべきものがUIであるということです。

そして、UIに対して直接操作する思考があれば、それはさっさと川に流してしまうべきです。あくまで状態を投影した結果がUIであり、UIが自発的に行動することはありえません。

## 画面本位の思考も捨てよ、必ずしもViewModelに固執するな

Providerがつきつめれば原子的状態管理に帰結することを**理解したうえであえて**ViewModel的に用いることと、クリーンアーキテクチャの表面的な例示(UseCaseがどうとかPresenterがどう)とか、あるいはこれまでのMVVMパターンに固執してProviderを利用するのでは、大きく異なります。

なぜ固執してしまうのでしょうか？それは我々人間が、あるいはシステム屋が、**表面的に投影された本質を必ずしも現れすとも限らない画面**を以て機能を見てしまうからです。画面という単位はたまたまそのように状態が寄せ集められた集合に過ぎず、たとえば乗換検索画面に広告が表示されるからといって`SearchState`に`Ad`を入れろというのはあまりに機能と責務の逸脱が過ぎます。なのに、画面という単位が便利だから、表面上工程を管理しやすいからという理由で一緒にされてしまいます。

広告が表示される画面のすべてのViewModelのStateに`required Ad`をしろというのは極端な例ですが、設計から愚直に構築するとそうならざるをえない矛盾を一度は感じたことがあるのではないでしょうか。

あるいはこれまでの、特に宣言型UIが採用されるまでのスマホアプリにおけるアーキテクチャが、Fragmentに対するViewModelに何でも詰める、Viewに対するViewControllerに対して何でも状態を詰める、そういった風潮が当然という潮流から来ているというのも考えられます。

少なくともFlutterはAndroidのライフサイクルに密結合した仕組みを持っているわけではないのだから、これまでのAndroidのアーキテクチャや、あるいは未だに呪縛のように結合しているJetpack Composeの、navgraphやFragmentに依存するViewModelに縛られる必要はなく、あるいはUIKitでもないのだからViewControllerなるものが必要でもありません。

結局のところ、画面本位であることはその時点で根本的なアンチパターンとしか言いようがありません。これはクリーンアーキテクチャがどうとかいう問題ではなく、根本的な責務の分離の手法の問題です。

必要なのは機能全体の視野であり、単独の画面でいいわけがありません。

## 「本質的な」クリーンアーキテクチャを守れ

依存関係の単方向性は崩してはなりません。だれがどこでどう依存するか、循環的参照を発生をみれば依存グラフがそもそも構築できなくなります。

もしもriverpod_generatorが`Stack overflow`で停止したとき、それはクリーンアーキテクチャから逸脱しているということです。これはジェネレーター時点で既に回避しえている点がある意味では救いです。しかし必ずしも`Stack overflow`を吐きうるわけでもないので、これに頼っていればよいかといえばそうでもありません。

これはUseCaseとかこれはPresenterとかいう表面的な議論は重要ではなく、RiverpodにはRiverpodなりのクリーンアーキテクチャの表現手法が既に存在しているわけです。あるProviderがUseCaseに実質相当するといえたとしても、必ずしもUseCaseという名前を名乗らなければならないルールはクリーンアーキテクチャにはありません。

クリーンアーキテクチャで得られるメリットはどのようなものでしょうか？前述のとおり、Flutterを使っている時点で、どうあがいても状態に従属して構築されるウィジェットツリーから導出されるUIにしかなりえない構図がある以上、最初から**UI非依存**です。

では**フレームワーク非依存**とはどうでしょうか？より中心側にいる層が、UIフレームワークや永続化や通信といった詳細に依存しないことを指します。

このことは、ドメインモデルなり、あるいはエンティティなるものは、当然Flutterで記述する以上はfreezedでイミュータブルとされ、これが処理を持たないのですから、本質はそこにあるべきです。

その外側にいるUseCaseが具体なるフレームワーク、それこそRiverpodに依存するなとかいう話は意味不明ですし、そもそもの話が履き違えています。というより、そもそもUseCaseという層がクリーンアーキテクチャにおいて必須とは誰もそもそも言っていません。

**テスト可能**。これもUIが純粋関数であればそれ単体でテストが当然可能です。状態の組み合わせ、これはたとえばMediaQueryとかのより上位に依存するウィジェットが下位に伝播させるものも含めてですが、これも組み合わせて当然テスト可能です。副作用を持つ契機があったとしても副作用そのものを持ち得なければテスト可能です。

ローカル状態を持つウィジェットであっても、それが外部状態に直接依存しない限りはこれもテスト可能です。

そして、Riverpodを用いている限りは、モックの状態をProviderScopeで注入できる以上、Riverpodで管理され、取りうるすべての状態はテスト可能です。Riverpodの何某かの層を表現するProviderまでたどり着いたとしても、最終的に副作用を持ち得るProviderをモック化すれば、テストという関数が全体として冪等になります。

すなわち、

- Riverpodをatomicに使おうが、MVVMとして使おうが関係なく、
- 依存関係逆転の法則さえ適切であり、
- ウィジェットが純粋関数か、副作用が内的にとどまっているかのどちらかであり、
- モデルがイミュータブルであれば、

これはすなわちクリーンアーキテクチャであることは達成できているのです。

そもそものクリーンアーキテクチャにおいて、UseCaseだのPresenterだのという層はあくまで例示に過ぎなかったはずです。これを履き違えて、表面的な理解にとどまってRiverpodに適用するにはこんなUseCaseを作ってという記事が未だに散見されますが、本質的にクリーンアーキテクチャとはそういうものであったはずです。

## まとめ

本章では、特に3点、FlutterとRiverpodでアンチパターン的思考に陥りやすい点についてみていきました。これは呪詛のようにすら映りますが、**私自身の過去への戒め**でもあります。なぜあのとき失敗したのか？という禅問答は、結局のところより普遍的な解にたどり着き、それは車輪の再発明であったとしても、自分のものとなります。

次の章が最後としますが、宣言型UIが将来どのように寄与するのかについて考察していきたいと思います。